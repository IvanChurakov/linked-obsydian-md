#алгоритми #теорія_алгоритмів #О-нотація #C #бінарний_пошук #оптимізація
## Вступ

**Бінарний пошук** - це алгоритм пошуку елемента в відсортованому масиві, який працює, рекурсивно або ітеративно поділяючи масив навпіл, доки шуканий елемент не буде знайдений або діапазон пошуку не зведеться до нуля. У цій статті ми розглянемо принцип дії алгоритму бінарного пошуку, проаналізуємо складність алгоритму, розглянемо переваги та недоліки бінарного пошуку, обговоримо місця бажаного використання алгоритму, наведемо конкретні приклади застосувань та приведемо код на C#.
## Принцип роботи

Бінарний пошук працює на основі поділу відсортованого масиву доки не знайде шуканий елемент або не вичерпає можливості подальшого поділу. Бінарний пошук починається зі середнього елемента масиву, порівнюючи його з шуканим значенням. Якщо дане значення збігається зі шуканим елементом, пошук успішно завершений. Якщо шуканий елемент більший за середній, пошук повторюється у правій половині масиву, і навпаки - у лівій половині, якщо менший. Процес продовжується, поки масив не буде зведений до одного елемента або не буде вичерпаний діапазон пошуку.
## Складність алгоритму бінарного пошуку

Складність бінарного пошуку становить _O(log n)_ для найгіршого, найкращого та середнього випадку, де _n_ - кількість елементів у масиві. Це пов'язано з тим, що з кожним кроком алгоритму розмір масиву зменшується вдвічі, а таким чином виконується _log (base 2) n_ операцій.

Порівняно з лінійним пошуком, який для масивів значного розміру може мати достатньо велику складність _O(n)_, бінарний пошук є більш ефективним алгоритмом.
## Переваги та недоліки бінарного пошуку
### Переваги:

1. **Швидкість**: бінарний пошук набагато швидший, ніж лінійний пошук, особливо на великих масивах.
2. **Ефективність**: з наростанням розміру масиву ефективність бінарного пошуку збільшується.
### Недоліки:

1. **Попередня сортування**: бінарний пошук можна застосовувати лише до відсортованих масивів.
2. **Неможливість впровадження на посилальні структури даних**: через відсутність можливості прямого доступу до елементів, бінарний пошук не можна застосувати для об'єктів типів структур даних, таких як зв'язні списки.
## Місця бажаного використання алгоритму

1. **Пошук на відсортованих масивах**: бінарний пошук ідеально підходить для відшукання елементів у великих відсортованих масивах.
2. **Прискорення операцій пошуку**: якщо операції пошуку в масиві виконуються часто, варто розглянути можливість переходу на відсортований масив та використання бінарного пошуку.
## Приклад

Розглянемо приклад бінарного пошуку на такому відсортованому масиві: {5, 10, 15, 20, 25, 30, 35, 40}.

Задача: знайти елемент 25.

1. Ми перевіряємо середній елемент масиву (7 елементів зліва, 7 зправа) - елемент 20. 20 < 25, тому ми відкидаємо ліву половину масиву.
2. Залишилося 3 елементи {25, 30, 40}. Ми знову працюємо з середнім значенням - елементом 30. 30 > 25, тому ми відкидаємо праву половину масиву.
3. Наступний середній - елемент 25, це те, що нам потрібно для успішного завершення алгоритму.
## Реалізація на C\#

```cs
using System;

class BinarySearchExample
{
    public static int BinarySearch(int[] arr, int value)
    {
        int low = 0;
        int high = arr.Length - 1;

        while (low <= high)
        {
            int mid = (low + high) / 2;
            if (arr[mid] == value)
            {
                return mid;
            }
            if (arr[mid] < value)
            {
                low = mid + 1;
            }
            else
            {
                high = mid - 1;
            }
        }

        return -1; // значення не знайдено
    }

    public static void Main()
    {
        int[] arr = {5, 10, 15, 20, 25, 30, 35, 40};
        int value = 25;
        int index = BinarySearch(arr, value);

        if (index != -1)
        {
            Console.WriteLine($"Значення {value} знайдено на позиції {index}");
        }
        else
        {
            Console.WriteLine($"Значення {value} не знайдено");
        }
    }
}
```
