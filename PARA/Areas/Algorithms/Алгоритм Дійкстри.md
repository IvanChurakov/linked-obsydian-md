#алгоритми #теорія_алгоритмів #О-нотація #C #пошук_найкоротшого_шляху #алгоритм_дійкстри #граф #орієнтований_граф #оптимізація
## Вступ

**Алгоритм Дійкстри** - це популярний алгоритм для пошуку найкоротших шляхів від заданої вершини до всіх інших вершин в орієнтованому графі з не від'ємними вагами. Він був розроблений відомим голландським інформатиком Едсгером Дійкстрой у 1959 році.
## Принципи роботи алгоритму Дійкстри

Алгоритм Дійкстри працює, виконуючи наступні етапи:

1. Ініціалізується початкова вершина (джерело) та її відстань ( для джерела вона 0, для інших вершин - нескінченність).
2. Визначається вершина з найменшою відстанню, яка ще не була оброблена, та видаляється з черги.
3. Релаксація ребер - перевірка, чи може відстань до суміжних вершин бути поліпшена. Якщо може, то відстань оновлюється.
4. Кроки 2 та 3 повторюються, доки черга не опустіє.
## Складність алгоритму

Алгоритм Дійкстри має часову складність *O(V^2)*, де V - кількість вершин. Проте, застосування двійкової купи може зменшити часову складність до *O(V log V + E)*, де E - кількість ребер.
## Переваги та недоліки

### **Переваги**:

- Використовується для знаходження найкоротших шляхів в графі з не від'ємними вагами.
- Простота розуміння та реалізації.
### **Недоліки**:

- Не працює з графами з від'ємними вагами.
- Не обов'язково знаходить найкоротший шлях в графах, де ваги ребер можуть змінюватися.
## Місця бажаного використання алгоритму

Алгоритм Дійкстри широко використовується в сфері мереж, де потрібно знайти найкоротший шлях для передачі даних. Інші області застосування включають GPS-навігацію, планування маршрутів в грах, телекомунікації.
## Приклад

Розглянемо граф з 5 вершинами де стартова вершина це 0. Ваги ребер графу представлені матрицею:
```
[
[0, 9, 4, 0, 0],
[6, 0, 12, 1, 0],
[0, 0, 0, 0, 0],
[0, 0, 1, 0, 15],
[0, 0, 0, 3, 0]
]
```
Для даного графу алгоритм Дійкстри почне з вершини 0 та знайде найкоротші шляхи до всіх інших вершин:

- Від вершини 0 до вершини 1: вага 9
- Від вершини 0 до вершини 2: вага 4
- Від вершини 0 до вершини 3: вага 2 (через вершину 2)
- Від вершини 0 до вершини 4: вага 5 (через вершини 2 та 3)
## Реалізація на C\#

```cs
class Graph {
    static readonly int INF = int.MaxValue;
    readonly int V = 5;

    int MinDistance(int[] dist, bool[] sptSet) {
        int min = INF, min_index = -1;
        for(int v = 0; v < V; v++) {
            if(!sptSet[v] && dist[v] <= min) {
                min = dist[v];
                min_index = v;
            }
        }
        return min_index;
    }

    void PrintSolution(int[] dist) {
        for(int i = 0; i < V; i++) {
            Console.Write($" {i}  {dist[i]} \n");
        }
    }

    public void Dijkstra(int[,] graph, int src) {
        int[] dist = new int[V];
        bool[] sptSet = new bool[V];
        for(int i = 0; i < V; i++) {
            dist[i] = INF;
            sptSet[i] = false;
        }
        dist[src] = 0;
        for(int count = 0; count < V - 1; count++) {
            int u = MinDistance(dist, sptSet);
            sptSet[u] = true;
            for(int v = 0; v < V; v++) {
                if(!sptSet[v] && Convert.ToBoolean(graph[u, v]) && dist[u] != INF && dist[u] + graph[u, v] < dist[v]) {
                    dist[v] = dist[u] + graph[u, v];
                }
            }
        }
        PrintSolution(dist);
    }
}
```
