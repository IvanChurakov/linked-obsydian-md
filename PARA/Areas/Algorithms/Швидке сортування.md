#алгоритми #теорія_алгоритмів #О-нотація #C #оптимізація #сортування #швидке_сортування #розділяй_та_володарюй
## Вступ

**Швидке сортування** — це алгоритм сортування масивів, що працює на основі рекурсивного розділення масиву та подальшого злиття відсортованих частин. Швидке сортування є одним з найшвидших алгоритмів сортування в середньому випадку. У цій статті ми розглянемо принцип дії алгоритму швидкого сортування, проаналізуємо складність алгоритму, розглянемо переваги та недоліки швидкого сортування, обговоримо місця бажаного використання алгоритму, наведемо конкретні приклади застосувань та приведемо код на C#.
## Принцип роботи

Швидке сортування працює на основі рекурсивної стратегії "розділяй та володарюй". Алгоритм вибирає півотний елемент (pivot) з масиву та розбиває масив на дві частини: елементи, що менші за півот, та елементи, які більші за півот. Після цього алгоритм рекурсивно сортує ці дві частини до завершення процесу.
## Складність алгоритму швидкого сортування

Загальна складність алгоритму швидкого сортування становить ***O(n log n)*** для середнього випадку, де _n_ - кількість елементів у масиві. Швидке сортування в середньому випадку буває значно швидшим, ніж масиви з квадратичною складністю, такі як сортування вибором або сортування вставкою. Однак, у найгіршому випадку, коли півот завжди є найменшим або найбільшим елементом, складність алгоритму швидкого сортування може скласти _O(n^2)_.
## Переваги та недоліки швидкого сортування

### Переваги:

1. **Висока швидкість**: швидке сортування є одним з найшвидших загальних алгоритмів сортування, особливо в середньому випадку, зі складністю _O(n log n)_.
2. **Широкі можливості оптимізації**: алгоритм швидкого сортування можна оптимізувати під конкретні умови та досягти відмінної продуктивності.

### Недоліки:

1. **Складність реалізації**: алгоритм швидкого сортування може бути складніший для зрозуміння та реалізації порівняно з простішими алгоритмами.
2. **Нестабільність**: алгоритм швидкого сортування є нестабільним алгоритмом, який може порушити порядок подібних елементів послідовності вихідних даних.
3. **Найгірший випадок**: можливість найгіршого випадку зі складністю O(n^2).
## Місця бажаного використання алгоритму

1. **Сортування великих масивів**: швидке сортування є хорошим вибором для сортування великих масивів з непередбачуваною структурою даних.
2. **Сортування масивів, що містять число і відмінних значень**: швидке сортування ефективно сортує масиви з багатьма різними значеннями.
3. **Універсальні ситуації**: як замість алгоритмів сортування з квадратичною складністю у тих випадках, коли пріоритетом є швидкість сортування.
## Приклад

Розглянемо приклад швидкого сортування на такому масиві: {30, 10, 20, 50, 70, 40, 60}.

Задача: відсортувати масив за зростанням.

1. Беремо півотом середній елемент - 20.
2. Міняємо місцями півот і покажчик на перший елемент - масив тепер виглядає так: {20, 10, 30, 50, 70, 40, 60}.
3. Розділяємо масив на дві частини: {10} і {30, 50, 70, 40, 60}.
4. Процедура продовжується у рекурсії для кожної частини масиву.
5. Збираємо масив із відсортованих частин - отримуємо: {10, 20, 30, 40, 50, 60, 70}.
## Реалізація на C\#

```cs
using System;

class QuickSortExample
{
    public static void QuickSort(int[] arr, int low, int high)
    {
        if (low < high)
        {
            int pivotIndex = Partition(arr, low, high);
            QuickSort(arr, low, pivotIndex - 1);
            QuickSort(arr, pivotIndex + 1, high);
        }
    }

    public static int Partition(int[] arr, int low, int high)
    {
        int pivot = arr[(low + high) / 2];
        int i = low - 1;
        int j = high + 1;

        while (true)
        {
            do
            {
                i++;
            } while (arr[i] < pivot);

            do
            {
                j--;
            } while (arr[j] > pivot);

            if (i >= j)
            {
                return j;
            }

            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }

    public static void Main()
    {
        int[] arr = {30, 10, 20, 50, 70, 40, 60};
        QuickSort(arr, 0, arr.Length - 1);

        Console.WriteLine("Відсортований масив:");
        foreach (int item in arr)
        {
            Console.Write(item + " ");
        }
    }
}
```