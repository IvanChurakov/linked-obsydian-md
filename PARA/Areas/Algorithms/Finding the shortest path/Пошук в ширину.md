#алгоритми #теорія_алгоритмів #О-нотація #C #пошук #пошук_в_ширину #BFS #граф #оптимізація
## Вступ

**Пошук в ширину (BFS - breadth-first search)** - це стратегія обходу або пошуку в графі, яка розпочинається з кореневої вершини та роздає відвідані вершини на їх відстань від кореня. Він є однією з найпростіших і найзагальніших стратегій для роботи з графами. У цій статті ми розглянемо принципи роботи BFS, його застосування, а також покрокове кодування BFS.
## Принципи роботи

Пошук в ширину починається з кореневої вершини (зазвичай це вершина 0 у ненаправленому графі) та досліджує всі вершини на відстані k перед тим, як перейти до вершин на відстані k+1.

Для визначення порядку обходу BFS використовує структуру даних, відому як черга. Вершини, які щойно були відвідані, додаються до кінця черги. При цьому найстарші кореневі вершини, які знаходяться на початку черги, перші відвідуються новими вершинами. Це гарантує, що BFS відвідає вершини за порядком зростання відстані від кореня.
## Складність алгоритму BFS

Складність алгоритму BFS можна визначити відносно вершин та ребер графа.

**Часова складність**: Часова складність обчислюється як *O(V + E)*, де V - кількість вершин, а E - кількість ребер. Така складність пояснюється тим, що кожна вершина і кожне ребро буде пройдено алгоритмом лише один раз.

**Складність по пам'яті**: BFS вимагає пам'яті для зберігання вершин. Отже, складність по пам'яті також *O(V)* для BFS. В ході виконання цього алгоритму черга може містити всі вершини графа в найгіршому випадку.

Отже, BFS вимагає значних ресурсів пам'яті, особливо для великих графів.
## Переваги та недоліки пошуку в ширину

### Переваги:

1. **Чіткість результату**: BFS надає чіткий шлях до вершини, забезпечуючи перевірку чіткості та надійності шляху.
2. **Гарантія знайдення найкоротшого шляху**: BFS гарантує знаходження найкоротшого шляху для ненаправленого графа.
3. **Застосування в різних областях**: BFS використовується в різних областях, таких як GPS-навігація, пошук шляху в мережі, тестування зв'язності в мережі, алгоритми широкого пошуку (наприклад, пошук в Інтернеті) і т.д.
### Недоліки:

1. **Використання пам'яті**: BFS використовує значний об'єм пам'яті, оскільки він має зберігати дані про всі вершини у черзі.
2. **Не підходить для оракулів-вирішенників задач**: BFS не підходить для вирішення задач за допомогою оракулів (систем, які можуть надавати відповіді на певні питання), тому що мінуси в пам’яті, що виникають в процесі виконання BFS, тут можуть бути катастрофічними.
3. **Більш повільний**, ніж пошук вглиб (DFS) для задач, коли треба знайти хоча б одну частину задачі, яка може бути розв'язана.
## Місця бажаного використання алгоритму

BFS застосовується в безлічі задач обробки графів, таких як:

1. **Визначення найкоротшого шляху в графі**: BFS може визначити найкоротший шлях до всіх вершин від вибраного джерела в ненаправленому графі, на відміну від DFS, який може відкрити шлях, але це не обов'язково буде найкоротшим шляхом.
2. **Визначення пов'язаності в ненаправленому графі**: BFS можна використовувати для перевірки, чи існує шлях між двома вершинами в ненаправленому графі.
## Приклад

Припустимо, що ми маємо ненаправлений, невагомий граф з 8 вершинами (від 1 до 8) і зв'язками, подані нижче:

- Вершина 1 з'єднана з вершинами 2, 3 та 6.
- Вершина 2 з'єднана з вершинами 1 та 4.
- Вершина 3 з'єднана з вершинами 1 та 4.
- Вершина 4 з'єднана з вершинами 2, 3, 5 та 6.
- Вершина 5 з'єднана з вершинами 4 та 7.
- Вершина 6 з'єднана з вершинами 1, 4 та 7.
- Вершина 7 з'єднана з вершинами 5, 6, та 8.
- Вершина 8 з'єднана з вершиною 7.

Пошук в ширину, який починається з вершини 1, буде виконуватися наступним чином:

1. Відвідуємо вершину 1, вершини 2, 3 та 6 додаємо в чергу.
2. Вершина 2 видаляється з черги і відвідується, вершина 4 додається до черги.
3. Вершина 3 видаляється з черги і відвідується, але всі її сусіди вже були відвідані або знаходятся в черзі, тому в чергу не додаються нові вершини.
4. Вершина 6 видаляється з черги і відвідується, вершина 7 додається до черги.
5. Вершина 4 видаляється з черги і відвідується, вершина 5 додається до черги.
6. Вершина 7 видаляється з черги і відвідується, вершина 8 додається до черги.
7. Вершини 5 та 8 послідовно видаляються з черги і відвідуються, нові вершини в чергу не додаються.

В кінці виконання BFS порядок обходу вельми близько відповідає відстаням від початкової вершини, а саме: 1-2-3-6-4-7-5-8.
## Реалізація на C\#

```cs
class Graph {
    private int _verticies;
    private List<int>[] _adj; 

    public Graph(int v) {
        _verticies = v;
        _adj = new List<int>[v];

        for (int i=0; i<v; ++i) 
            _adj[i] = new List<int>();
    }

    public void AddEdge(int v, int w) {
        _adj[v].Add(w);
    }

    public void BFS(int s) {
        bool[] visited = new bool[_verticies];
        Queue<int> queue = new Queue<int>();
        visited[s] = true;
        queue.Enqueue(s);

        while(queue.Count != 0) {
            s = queue.Dequeue();
            Console.Write(s + " ");

            List<int> list = _adj[s];

            foreach (var val in list) {
                if (!visited[val]) {
                    queue.Enqueue(val);
                    visited[val] = true;
                }
            }
        }
    }
}
```