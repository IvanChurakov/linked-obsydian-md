#алгоритми #теорія_алгоритмів #О-нотація #C #пошук_найкоротшого_шляху #алгоритм_белмана_форда #граф #орієнтований_граф #оптимізація
## Вступ

**Алгоритм Белмана-Форда** є важливим алгоритмом для знаходження найкоротших шляхів. Він був названий на честь своїх розробників Річарда Белмана і Лестера Форда і є узагальненням алгоритму Дійкстри. Основна перевага цього алгоритму полягає в тому, що він може працювати з графами, що містять від'ємні ваги.
## Принципи роботи

Алгоритм Белмана-Форда працює, використовуючи принцип релаксації, що полягає в покращенні оцінки найкоротших шляхів. Ініціалізуються відстані до всіх вершин як нескінченні, крім відстані початкової вершини до самої себе, яка дорівнює нулю. Потім алгоритм робить V-1 проходів (де V - кількість вершин графа) по всіх ребрах графа, релаксуючи їх. Нарешті, алгоритм перевіряє наявність циклів від'ємної ваги.
## Складність алгоритму

Часова складність алгоритму Белмана-Форда становить *O(V\*E)*, де V - кількість вершин графу, а E - кількість ребер графу.
## Переваги та недоліки

### **Переваги**:

- Може працювати з графами, що мають ребра з від'ємною вагою.
- Здатний виявляти цикли від'ємної ваги.
### **Недоліки**:

- Має більшу часову складність, ніж алгоритм Дійкстри.
- Не працює, якщо в графі є цикл від'ємної ваги, досяжний з початкової вершини.
## Місця бажаного використання алгоритму

Алгоритм Белмана-Форда може бути використаний в будь-якій мережі або графі, де потрібно вирішити проблему найкоротшого шляху в умовах наявності від'ємних ваг. Він є основою для багатьох протоколів маршрутизації, таких як RIP.
## Приклад

Припустимо ми маємо орієнтований граф з п'ятьма вершинами та вагами ребер між ними. Нехай початковою вершиною є вершина 1. Після виконання алгоритму Белмана-Форда отримаємо найкоротші шляхи від вершини 1 до всіх інших вершин.
## Реалізація на C\#
```cs
class Graph
{
    class Edge {
        public int src, dest, weight;
        public Edge() {
            src = dest = weight = 0; 
        }
    };

    int V, E;
    Edge[] edge;

    public Graph(int v, int e) {
        V = v;
        E = e;
        edge = new Edge[e];
        for (int i=0; i<e; ++i)
             edge[i] = new Edge();
    }
  
    void BellmanFord(Graph graph, int src)
    {
        int V = graph.V, E = graph.E;
        int[] dist = new int[V];

        for (int i = 0; i < V; ++i)
            dist[i] = int.MaxValue;
        dist[src] = 0;
  
        for (int i = 1; i < V; ++i) {
            for (int j = 0; j < E; ++j) {
                int u = graph.edge[j].src;
                int v = graph.edge[j].dest;
                int weight = graph.edge[j].weight;
                if (dist[u] != int.MaxValue && dist[u] + weight < dist[v])
                    dist[v] = dist[u] + weight;
            }
        }
  
        for (int j = 0; j < E; ++j) {
            int u = graph.edge[j].src;
            int v = graph.edge[j].dest;
            int weight = graph.edge[j].weight;
            if (dist[u] != int.MaxValue && dist[u] + weight < dist[v]) {
              Console.WriteLine("Graph contains negative weight cycle");
              return;
            }
        }

        printArr(dist, V);
    }
  
    void printArr(int[] dist, int V)
    {
        Console.WriteLine("Vertex Distance from Source");
        for (int i = 0; i < V; ++i)
            Console.WriteLine(i + "\t\t" + dist[i]);
    }
}
```